.. _topics-registry:

=================
Merengue registry
=================

.. highlightlang:: html+django


Introduction
============

In any modern cms you usually have several components that will be registered
and/or configured in every installed site. This registration and configurations
parameters would be defined by superuser in merengue admin interface. All would
be stored in database.

Example use cases:

* Registering plugins, with plugin options (see :ref:`plugin development docs <topics-plugins-overview>`).
* Registering actions with configuration parameters (see :ref:`actions docs <topics-actions>`).
* Storing user preferences.
* Theme configuration (basic colors, etc.).


Using registry
==============

Example use case
----------------

*Use case is*: imagine we wants to implement a plugin registering system, with
plugins configurable by developers. This is the current Merengue `pluggable module`_.

.. _`pluggable module`: http://dev.merengueproject.org/browser/trunk/merengueproj/merengue/pluggable/__init__.py

Defining a registrable and configurable component
-------------------------------------------------

First step is defining a registrable component. This is a Python class that
must inherits from ``merengue.registry.items.RegistrableItem`` class:

.. code-block:: python

    from merengue.registry.items import RegistrableItem

    class Plugin(RegistrableItem):

        @classmethod
        def get_category(cls):
            return 'plugin'

The ``get_category`` method is needed, and say to Merengue what kind of objects
you will register.

With this example, you have created a base class for all plugins. A plugin
developer could declare his plugin with this fragment:

.. code-block:: python

    from merengue.pluggable import Plugin

    class PluginConfig(Plugin):
        name = 'fooplugin'

This is all you need to implement a registrable component.

Now we will consider we have implemented all pluggable system. Now we will
learn to use registry for registering and unregistering objects.

For testing previous code fragment, make a ``fooplugin`` directory into ``plugins``
directory, with a ``__init__.py`` file inside it and a ``config.py`` file. In
the last file, copy and paste previous code fragment.

How can I do plugin registering? With these sentences:

.. code-block:: python

    >>> from merengue.registry import register, is_registered, have_registered_items
    >>> from plugins.fooplugin.config import PluginConfig
    >>> have_registered_items(PluginConfig)
    False
    >>> reg_item = register(PluginConfig)
    >>> have_registered_items(PluginConfig)
    True
    >>> item = reg_item.get_registry_item()
    >>> is_registered(item)
    True

.. admonition:: Plugin autoregistering

    Note your first call to ``is_registered`` returns ``True``, this is
    because Merengue has plugin autoregistering activated and you have
    accessed to plugins admin view.

This sentences will register plugin by default in a ``RegisteredItem`` model in
database. The RegisteredItem model definition is in ``merengue.registry.models``
module.

.. admonition:: Note

    Do not confusing RegisteredItem with RegistrableItem. The latter is not a
    Django model but an registrable object. The first is a model that store all
    ``RegistrableItem``s have been registered with ``merengue.registry.register``
    function.

You can access to registered object with these sentences:

.. code-block:: python

    >>> from merengue.registry.models import RegisteredItem
    >>> RegisteredItem.objects.all().values()
    [{'class_name': u'PluginConfig', 'category': u'plugin', 'config': u'', 'id': 5, 'module': u'plugins.fooplugin.config'}]
    >>> RegisteredItem.objects.by_item_class(PluginConfig)
    [<RegisteredItem: PluginConfig>]

.. _topics-registry-configuration-params:

Configuring your registrable components
---------------------------------------

Let's look at this example:

.. code-block:: python

    from django.utils.translation import ugettext_lazy as _
    from merengue.pluggable import Plugin
    from merengue.registry import params

    class PluginConfig(Plugin):
        name = 'fooplugin'
        config_params = [
            params.Single(name='username', label=_('username'), default='pepe'),
            params.List(name='friends', label=_('friends'),
                        default=['antonio', 'juan'],
                        choices=[('antonio', 'Antonio'),
                                ('paco', 'Paco'),
                                ('rosa', 'Rosa'),
                                ('juan', 'Juan')]),
            params.Single(name='season', label=_('season'),
                        choices=[('spring', _('Spring')),
                                ('summer', _('Summer')),
                                ('autumn', _('Autumn')),
                                ('winter', _('Winter'))]),
        ]

Automatically, with this configuration, you can access to registered item in
admin and will see and configure all parameters of this component:

.. image:: _images/registry_config.png

If plugin developer want to access this configuration (remember, the
configuration you customize in admin, no the default config_params for plugin),
he would use these sentences:

.. code-block:: python

    >>> from plugins.fooplugin.config import PluginConfig
    >>> config = PluginConfig.get_config()
    >>> print config['friends'].value
    ['paco', 'juan']
    >>> print config['friends'].choices
    [('antonio', 'Antonio'), ('paco', 'Paco'), ('rosa', 'Rosa'), ('juan', 'Juan')]
    >>> print config['friends'].default
    ['antonio', 'juan']
    >>> config['friends'].get_type()
    'List'

If you register a registrable item, you also will save this configuration in
database. See this example:

    >>> class PersonItem(RegistrableItem):
    ...     config_params = [
    ...         params.Bool(name='is_human', default=True),
    ...         params.Integer(name='age'),
    ...         params.List(name='friends', choices=('Juan', 'Luis', 'Pepe'))
    ...     ]
    ...
    >>> register(PersonItem)
    >>> PersonItem.get_config()
    {'is_human': <True, Bool>,
    'age': <<class 'merengue.registry.params.NOT_PROVIDED'>, Integer>,
    'friends': <<class 'merengue.registry.params.NOT_PROVIDED'>, List>}
    >>> reg_item = PersonItem.get_registered_item()
    >>> reg_item.config
    {u'is_human': True}
    >>> reg_item.config['age'] = 30
    >>> reg_item.save()
    >>> PersonItem.get_config()
    {'is_human': <True, Bool>,
    'age': <30, Integer>,
    'friends': <<class 'merengue.registry.params.NOT_PROVIDED'>, List>}

Merging configurations
----------------------

Sometimes a plugin developer want to override a default configuration with
other configurations. This happens for example in block configuration, which
may be overrided when I place a specific block for a specific content. In this
case, block configuration was the merging of the global configuration and the
specific configuration in that content. An example API use:

.. code-block:: python

    >>> PersonItem.get_config()
    {'is_human': <True, Bool>,
    'age': <<class 'merengue.registry.params.NOT_PROVIDED'>, Integer>,
    'friends': <<class 'merengue.registry.params.NOT_PROVIDED'>, List>}
    >>> PersonItem.get_merged_config(params.ConfigDict(config_params, {'is_human': False, 'age': 35}))
    {'is_human': <False, Bool>,
    'age': <35, Integer>,
    'friends': <<class 'merengue.registry.params.NOT_PROVIDED'>, List>}
    >>> PersonItem.get_merged_config(
    ...     params.ConfigDict(config_params, {'age': 35}),
    ...     params.ConfigDict(config_params, {'age': 15}),
    ... )
    {'is_human': <True, Bool>,
    'age': <15, Integer>,
    'friends': <<class 'merengue.registry.params.NOT_PROVIDED'>, List>}
